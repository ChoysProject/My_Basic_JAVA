package Chapter_03_03;

public class Operator_06 {

	public static void main(String[] args) {

		// 산술 연산자 (+, -, *, /, %)
		
		// 우리가 일반적으로 말하는 사칙 연산인 더하기(+), 빼기(-), 곱하기(*), 나누기(/)와 나머지를 구하는 연산자 (%)를 포함해서 산술 연산자는 총 5개이다.
		// 이 산술 연산자는 boolean 타입을 제외한 모든 기	본 타입에 사용 할 수 있다.
		
		// 피연산자	+	피연산자	덧셈연산
		// 피연산자	-	피연산자	뺼셈연산
		// 피연산자	*	피연산자	곱셉연산
		// 피연산자	/	피연산자	좌측 피연산자를 우측 피연산자로 나눗셈 연산
		// 피연산자	%	피연산자	좌측	피연산자를 우측 피연산자로 나눈 나머지를 구하는 
		
		
		// 산술 연산자는 우리가 익히 알고 있기 때문에 따로 설명을 하지 않아도 될 것 같다.
		// 주의할 점은 곱셈의 경우 연산자가 x가 아니라 *를 사용하고, 나눈셈의 경우 /를 사용한다.
		// % 연산자가 조금 생소할 지도 모르겠다.
		// % 연산자는 나눗셈을 수행하고, 몫이 아닌 나머지를 돌려주는 연산자이다.
		// int reuslt = num % 3; 에서 result에 저장되는 값은 num의 값에 따라 0,1,2 중 한값이 된다.
		// 왜냐하면 어떤 수를 3으로 나누었을 경우 나머지는 세 숫자 중 하나이기 떄문이다.
		
		// 산술 연산자의 특징은 피연산자들의 타입이 동일하지 않을 경우 다음과 같은 규칙을 사용해서 피연산자들의 타입을 일치시킨 후 연산을 수행한다.
		
		// 1. 피연산자들의 모두 정수타입이고, int 타입보다 크기가 작은 타입일 경우 모두 int 타입으로 변환호, 연산을 수행한다. 따라서 연산의 산출 타입은 int다.
		// byte + byte -> int + int = int
		
		// 2. 피연산자들이 모두 정수 타입이고, long 타입이 있을 경우 모두 long타입으로 변환 후, 연산을 수핸한다. 따라서 연산의 산출타입은 long이다.
		// int + long -> long + long = long
		
		// 3. 피연산자 중 실수 타입(float 타입, double 타입)이 있을 경우, 크기가 큰 실수 타입으로 변환 후, 연산을 수행한다. 따라서 연산의 산출 타입은 실수 타입이다.
		// int + double -> double + double = double
		
		// 간단하게 정리하면 long을 제외한 정수 타입 여난은 int 타입으로 산출되고, 피연산자 중 하나라도 실수 타입이면, 실수타입으로 산출된다.
		
		byte byte1 = 1;
		byte byte2 = 1;
//		byte byte3 = byte1 + byte2; // 컴파일 에러 long 외에 정수의 산술 연산은 무조건 int 타입으로 변환후 연산을 수행하고, 산출 타입이 int이기 때문에 int 타입 변수에 산출 값을 대입해야한다.
		
		// 따라서 다음과 같이 수정해야한다.
		
		int result1 = byte1 + byte2;
		
		// 정수 타입 연산의 결과가 int 타입으로 나오는 이유는 자바 가상 기계(JVM)가 기본적으로 32비트 단위로 계산하기 떄문이다. 다른 예를 들어보자.
		// 다음 코드에서 result2와 result3에 저장되는 값은 무엇인지 알아보자.
		
		int int1 = 10;
		int int2 = 4;
		int result2 = int1 / int2;
		double result3 = int1 / int2;
		
		System.out.println("result2 = " + result2);
		System.out.println("result3 = " + result3);
		
		// 상식적으로 생각하면 int1과 int2를 나눗셈 하면 2.5가 나오지만 연산결과는 소수점 이하 부분을 버리고 2만 산출된다. 따라서 result2에는 2가 저장된다. 그렇다면 result3은 double 타입 변수이므로 2.5가 저장될까? 
		// 정답은 아니다.
		// 연산후의 결과가 2이므로 2를 실수화해서 2.0이 된다.
		// 만약 2.5를 산출결과로 얻고 싶다면 피연산자 중 최소한 하나는 실수 타입이어야 한다.
		
		double result4 = (int1*1.0) / int2;
		double result5 = (double) int1/int2;
		double result6 = int1 / (double) int2;
		
		System.out.println("result4 = " + result4);
		System.out.println("result5 = " + result5);
		System.out.println("result6 = " + result6);
		
		
		// 오버 플로우 탐지
		
		// 산술 연산을 할때 주의할 점은 연산 후의 산출값이 산출 타입으로 충분히 표현 가능한지 살펴봐야 한다.
		// 산출 타입으로 표현할 수 없는 값이 산출되었을 경우, 오버플로우가 발생하고 쓰레기값 (엉뚱한 값)을 얻을 수 있기 때문이다.
		
		
		
		// NaN과 Infinity 연산
		
		// / 또는 % 연산자를 사용할 때도 주의할 점이 있다. 좌측 피연산자가 정수 타입인 경우 나누는 수인 우측 피연산자는 0을 사용할 수 없다. 만일 0으로 나누면 
		// 컴파일은 정상적으로 되지만, 실행 시 ArithmeticException(예외)이 발생한다.
		
		// 5 / 0 -> ArithmeticException 예외 발생
		// 5 % 0 -> ArithmeticException 예외 발생
		
		// 자바는 프로그램 실행 도중 예외가 발생하면 실행이 즉시 멈추고 프로그램은 종료된다. ArithmeticException이 발생했을 경우 프로그램이 종료되지 않도록 하려면
		// 예외 처리를 해야한다. 예외가 발생되었을 경우, catch 블록을 실행하도록 하는것이다.
		
//		try {
//			// int z= x / y;
//			int z= x % y;
//			System.out.println("z : " + z);
//		}catch(ArithmeticException e) {
//			System.out.println("0으로 나누면 안됨");
//		}
		
		// 그러나 실수 타입인 0.0 또는 0.0f로 나누면 ArithmeticException 발생하지 않고, / 연산의 결과는 Infinity (무한대) 값을 가지며, % 연산의 결과는 NaN(Not a Nubmer)을 가진다.
		
		// Infinity + 2; => Infinity
		// NaN + 2; => NaN
		
		//프로그램 코드에서 / 와 % 연산의 결과가 Infinity 또는 NaN 인지 확인하려면 Double.isInfinite()와 Double.isNaN()메서드를 서용하면된다.
		
		// 이 메서드들은 double 타입의 값을 매개값으로 받아서 이 값이 Infinity 또는 NaN 이라면 true를 리턴하고, 그렇지 않다면 false를 리턴한다.
		
		// 연산의 결과가 Infinity 또는 NaN이면 절대로 다음 연산을 수행하지 못하도록 if문을 사용해서 실행 흐름을 변경해야 한다. 
		
		
		/*	if(Double.isInfinite(z) || Double.isNaN(z)){
		 * 	System.out.println("값 산출 불가");
		 * 	}else {
		 * 	System.out.println(z + 2);
		 * 	}
		 */

	
		// 문자열 연결 연산자(+)
		// 문자열 연결 연산자인 +는 문자열을 서로 결합하는 연산자이다.
		// + 연산자는 산술 연산자, 부호 연산자인 동시에 문자열 연결 연산자이기도 하다.
		// 피연산자 중 한쪽이 문자열이면 + 연산자는 문자열 연결 연산자로 사용되어 다른 피연산자를 문자열로 변환하고 서로 결합한다.
		
		String str1 = "JDK" + 6.0;
		String str2 = str1 + " 특징";
		
		System.out.println("str2 = " + str2);
	
//		3 + 3.0 + "JDK"; 실수로 계산되어 6.0JDK라는 결과가 나온다.
		
		
		// 비교 연산자 (<,<=,>,>=,==,!=)
		
		// 구분			연산식					설명
		// 동등비교		피연산자1 == 피연산자2		두 피연산자의 값이 같은지를 검사
		// 동등비교		피연산자1 != 피연산자2		두 피연산자의 값이 다른지를 검사
		// 크기비교		피연산자1 >  피연산자2		피연산자1이 큰지를 검사
		// 크기비교		피연산자1 >= 피연산자2		피연산자1이 크거나 같은지를 검사
		// 크기비교		피연산자1 <  피연산자2		피연산자2이 큰지를 검사
		// 크기비교		피연산자1 <= 피연산자2 		피연산자2이 크거나 같은지를 검사
		
		// 만약 피연산자가 char 타입이면 유니코드 값으로 비교 연산을 수행한다.
		// ('A'<'B') -> ('65'<'66')
		
		
		// Sting 타입 문자열을 비교할 때에는 대소(<, >, <=, >=) 연산자를 사용할 수 없고, 동등 비교연산자를 사용할 수 있으나.
		// 다른지를 비교하는 용도로는 사용되지 않는다.
		// 기본 타입인 변수값을 비교할 때에는 == 요ㅕㄴ산자를 사용하지만 참조 타입인 String 변수를 비교할때 == 연산자를 사용하면 원치 않는 결과가 나올 수도 있다.
		
		String strVar1 = "신용권";
		String strVar2 = "신용권";
		String strVar3 = new String("신용권");
		
//		strVar1 == strVar2 // true
//		strVar2 == strVar3 // flase
		
		// 동일한 String 객체이건 다른 객체이건 상관없이 String 객체의 문자열만을 비교하고 싶다면 == 연산자 대신에 equals를 사용해야한다.
		
		
		boolean result = str1.equals(strVar2);
		
		// 다음은 strVar1의 문자열과 strVar2의 문자열이 같은지 비교한다.
		// 그리고 strVar2의 문자열과 strVar3 문자열이 같은지 비교한다.
		
		
		
		// 논리 연산자
		
		// 논리 연산자는 논리곱(&&), 논리합(||), 배타적 논리합(^) 그리고 논리 부장(!) 연산을 수행한다.
		// 논리 연산자의 피연산자는 boolean 타입만 사용할 수 있다. 
		// 다음 표를 참고하자
		
		// 구분			연산식							결과				설명
		// 논리곱(AND)	true    && 또는 & 	true		true			피연산자 모두가 true일 경우에만 연산 결과는 true이다.
		// 논리곱(AND)	true	&& 또는 &		false		false			피연산자 모두가 true일 경우에만 연산 결과는 true이다.
		// 논리곱(AND)	flase	&& 또는 &		true		false			피연산자 모두가 true일 경우에만 연산 결과는 true이다.
		// 논리곱(AND)	flase	&& 또는 &		false		false			피연산자 모두가 true일 경우에만 연산 결과는 true이다.
		
		// 논리합(OR)		true    || 또는 | 	true		true			피연산자 중 하나만 true이면 연산의 결과는 true이다.
		// 논리합(OR)		true    || 또는 | 	false		true			피연산자 중 하나만 true이면 연산의 결과는 true이다.
		// 논리합(OR)		false   || 또는 | 	true		true			피연산자 중 하나만 true이면 연산의 결과는 true이다.
		// 논리합(OR)		false	|| 또는 |		false		false			피연산자 중 하나만 true이면 연산의 결과는 true이다.
		
		// 배타적 논리합	true		^		true		false			피연산자가 하나는 true이고 하나는 false일 경우에만 연산 결과는 true
		//	 (XOR)		true		^		false		true			피연산자가 하나는 true이고 하나는 false일 경우에만 연산 결과는 true
		// 배타적 논리합	false		^		true		true			피연산자가 하나는 true이고 하나는 false일 경우에만	 연산 결과는 true	
		//	 (XOR)		false		^		false		false			피연산자가 하나는 true이고 하나는 false일 경우에만 연산 결과는 true
				
		
		// 비트 연산자
		
		// 비트 연산자는 데이터를 비트 (bit) 단위로 연산한다. 즉 0과 1이 피연산자가 된다. 
		// 그렇기 때문에 0과 1로 표현이 가능한 정수 타입만 비트 연산을 할 수 있다. 실수 타입인 float와 double은 비트 연산을 할 수 없다.
		// 비트 연산자는 기능에 따라 비트 논리 연산자(&.|,^,~)와 비트 이동 연산자(<<,>>,>>>)로 구분한다. 일반 논리 연산자가 true와 false를 연산한다면 비트 논리 연산자는 0과 1을 연산한다.
		// 비트 이동 연산자는 비트를 좌측 또는 우측으로 이동하는 연산자이다.
		
		// 비트 논리 연산자에는 &, |, ^, ~가 있다. &, |, ^ 연산자는 피연산자가 boolean 타입일 경우에는 일반 논리 연산자이고, 피연산자가 정수 타입일 경우에는 비트 논리 연산자로 사용된다.
		// ~ 는 단항 연산자에서 이미 소개가 되었다. 
		
		// 구분			연산식						결과				설명
		// AND(논리곱)	1		&		1			1				두 비트 모두 1일 경우에만 연산결과가 1이다.
		// AND(논리곱)	1		&		0			0				두 비트 모두 1일 경우에만 연산결과가 1이다.
		// AND(논리곱)	0		&		0			0				두 비트 모두 1일 경우에만 연산결과가 1이다.
		// AND(논리곱)	0		&		0			0				두 비트 모두 1일 경우에만 연산결과가 1이다.
		
		// OR(논리합)		1		|		1			1				두 비트 중 하나만 1이면 연산 결과는 1이다.
		// OR(논리합)		1		|		0			1				두 비트 중 하나만 1이면 연산 결과는 1이다.
		// OR(논리합)		0		|		1			1				두 비트 중 하나만 1이면 연산 결과는 1이다.
		// OR(논리합)		0		|		0			0				두 비트 중 하나만 1이면 연산 결과는 1이다.
		
		// 배타적 논리합	1		^		1			0				두 비트 중 하나는 1이고 다른 하나가 0일 경우 연산 결과
		//	 (XOR)		1		^		0			1				두 비트 중 하나는 1이고 다른 하나가 0일 경우 연산 결과
		// 배타적 논리합	0		^		1			1				두 비트 중 하나는 1이고 다른 하나가 0일 경우 연산 결과
		//   (XOR)		0		^		0			0				두 비트 중 하나는 1이고 다른 하나가 0일 경우 연산 결과
		
		
		byte num1 = 45;
		byte num2 = 25;
//		byte result = num1 & num2; // 컴파일 에러 -> int result num1 % num2;
		
		
		
		// 비트 이동 연산자 (<<,>>,>>>)
		
		// 비트 이동(shift) 연산자는 정수 데이터의 비트를 좌측 또는 우측으로 밀어서 이동시키는 연산을 수행한다.
		// 다음은 비트 이동 연산을 수행하는 연산자의 종류와 기능을 설명한 표이다.
		
		// 구분			연산식					설명
		// 이동(시프트)	a		<<		b		정수 a의 각 비트를 b 만큼 왼쪽으로 이동(빈자리는 0으로 채워진다.)
		// 이동(시프트)	a		>>		b		정수 a의 각 비트를 b 만큰 오른쪽으로 이동(빈자리는 정수 a의 최상위 부호 비트(MSB)와 같은 값으로 채워진다.)
		// 이동(시프트)	a		>>>		b		정수 a의 각 비트를 b만큼 오른쪽으로 이동(빈자리는 0으로 채워진다.)
	
	
		// 대입 연산자 (=, +=, -=, *=, \=, %=, &=, ^=, |=, <<=, >>=, >>>=)
		
		// 구분			연산식						설명
		// 단순대입연산자	변수		 =		피연산자		우측의 피연산자의 값을 변수에 저장
		// 복합대입연산자	변수		+=		피연산자		우측의 피연산자의 값을 변수의 값과 더한 후에 다시 변수에 저장 (변수 = 변수 + 피연산자와 동일)
		// 복합대입연산자	변수		-=		피연산자		우측의 피연산자의 값을 변수의 값에서 뺀 후에 다시 변수에 저장 (변수 = 변수 - 피연산자와 동일)
		// 복합대입연산자	변수		*=		피연산자		우측의 피연산자의 값을 변수에 값에서 곱한 후에 다시 변수에 저장	(변수 = 변수 * 피연산자와 동일)
		// 복합대입연산자	변수		/=		피연산자		우측의 피연산자 값으로 변수의 값을 나눈 후에 다시 변수에 저장(변수 = 변수/피연산자오 동일)
		// 복합대입연산자	변수		%=		피연산자		우측의 피연산자의 값으로 변수의 값을 나눈 후에 나머지 변수에 저장(변수 = 변수 & 피연산자와 동일)
		// 복합대입연산자	변수		&=		피연산자		우측의 피연산자의 값과 변수의 값을 & 연산 후 결과를 변수에 저장(변수 = 변수 & 피연산자와 동일)
		// 복합대입연산자	변수		|=		피연산자		우측의 피연산자의 값과 변수의 값을 | 연산 후 결과를 변수에 저장 (변수 = 변수 | 피연산자와 동일)
		// 복합대입연산자	변수		^=		피연산자		우측의 피연산자의 값과 변수의 값을 ^ 연산 후 결과를 변수에 저장 (변수 = 변수 ^ 피연산자와 동일)
		// 복합대입연산자	변수		<<=		피연산자		우측의 피연산자의 값과 변수의 값을 << 연산 후 결과를 변수에 저장 (변수 = 변수 << 피연산자와 동일)
		// 복합대입연산자	변수		>>=		피연산자		우측의 피연산자의 값과 변수의 값을 >> 연산 후 결과를 변수에 저장 (변수 = 변수 >> 피연산자와 동일)
		// 복합대입연산자	변수		>>>=	피연산자		우측의 피연산자의 값과 변수의 값을 >>> 연산 후 결과를 변수에 저장 (변수 = 변수 >>> 피연산자와 동일)
		
	
		// 삼항 연산자
		
		// 삼항 연산자 (?:)는 세개의 피연산자를 필요로 하는 연산자를 말한다. 삼항 연산자는 ? 앞의 조건식에 따라 (:) 앞뒤의 피연산자가 선택된다고 해서 조건 연산식이라고 부르기도 한다.
		// 삼항 연산자를 사용하는 방법은 다음과 같다.
		
		int score = 95;
		char grade = score > 85 ? 'A' : 'B'; 
		
	}
}
